// Code generated by enum generator; DO NOT EDIT.
package enums

import (
	"fmt"

	"database/sql/driver"
)

// FilterMode is the exported type for the enum
type FilterMode struct {
	name  string
	value int
}

func (e FilterMode) String() string { return e.name }

// Index returns the underlying integer value
func (e FilterMode) Index() int { return e.value }

// MarshalText implements encoding.TextMarshaler
func (e FilterMode) MarshalText() ([]byte, error) {
	return []byte(e.name), nil
}

// UnmarshalText implements encoding.TextUnmarshaler
func (e *FilterMode) UnmarshalText(text []byte) error {
	var err error
	*e, err = ParseFilterMode(string(text))
	return err
}

// Value implements the driver.Valuer interface
func (e FilterMode) Value() (driver.Value, error) {
	return e.name, nil
}

// Scan implements the sql.Scanner interface
func (e *FilterMode) Scan(value interface{}) error {
	if value == nil {
		// try to find zero value
		for _, v := range FilterModeValues {
			if v.Index() == 0 {
				*e = v
				return nil
			}
		}
		// no zero value found, return error
		return fmt.Errorf("cannot scan nil into FilterMode: no zero value defined")
	}

	str, ok := value.(string)
	if !ok {
		if b, ok := value.([]byte); ok {
			str = string(b)
		} else {
			return fmt.Errorf("invalid filterMode value: %v", value)
		}
	}

	val, err := ParseFilterMode(str)
	if err != nil {
		return err
	}

	*e = val
	return nil
}

// _filterModeParseMap is used for efficient string to enum conversion
var _filterModeParseMap = map[string]FilterMode{
	"all":     FilterModeAll,
	"running": FilterModeRunning,
	"success": FilterModeSuccess,
	"failed":  FilterModeFailed,
}

// ParseFilterMode converts string to filterMode enum value
func ParseFilterMode(v string) (FilterMode, error) {

	if val, ok := _filterModeParseMap[v]; ok {
		return val, nil
	}

	return FilterMode{}, fmt.Errorf("invalid filterMode: %s", v)
}

// MustFilterMode is like ParseFilterMode but panics if string is invalid
func MustFilterMode(v string) FilterMode {
	r, err := ParseFilterMode(v)
	if err != nil {
		panic(err)
	}
	return r
}

// Public constants for filterMode values
var (
	FilterModeAll     = FilterMode{name: "all", value: 0}
	FilterModeRunning = FilterMode{name: "running", value: 1}
	FilterModeSuccess = FilterMode{name: "success", value: 2}
	FilterModeFailed  = FilterMode{name: "failed", value: 3}
)

// FilterModeValues contains all possible enum values
var FilterModeValues = []FilterMode{
	FilterModeAll,
	FilterModeRunning,
	FilterModeSuccess,
	FilterModeFailed,
}

// FilterModeNames contains all possible enum names
var FilterModeNames = []string{
	"all",
	"running",
	"success",
	"failed",
}

// FilterModeIter returns a function compatible with Go 1.23's range-over-func syntax.
// It yields all FilterMode values in declaration order. Example:
//
//	for v := range FilterModeIter() {
//	    // use v
//	}
func FilterModeIter() func(yield func(FilterMode) bool) {
	return func(yield func(FilterMode) bool) {
		for _, v := range FilterModeValues {
			if !yield(v) {
				break
			}
		}
	}
}

// These variables are used to prevent the compiler from reporting unused errors
// for the original enum constants. They are intentionally placed in a var block
// that is compiled away by the Go compiler.
var _ = func() bool {
	var _ filterMode = filterMode(0)
	// This avoids "defined but not used" linter error for filterModeAll
	var _ filterMode = filterModeAll
	// This avoids "defined but not used" linter error for filterModeRunning
	var _ filterMode = filterModeRunning
	// This avoids "defined but not used" linter error for filterModeSuccess
	var _ filterMode = filterModeSuccess
	// This avoids "defined but not used" linter error for filterModeFailed
	var _ filterMode = filterModeFailed
	return true
}()
