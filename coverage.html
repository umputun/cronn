
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>web: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/umputun/cronn/app/web/web.go (75.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package web

import (
        "bytes"
        "context"
        "crypto/sha256"
        "database/sql"
        "embed"
        "encoding/hex"
        "fmt"
        "html/template"
        "net/http"
        "sort"
        "sync"
        "time"

        log "github.com/go-pkgz/lgr"
        "github.com/robfig/cron/v3"
        _ "modernc.org/sqlite" // SQLite driver

        "github.com/umputun/cronn/app/crontab"
)

//go:embed templates/*.html templates/partials/*.html
var templatesFS embed.FS

//go:embed static/*
var staticFS embed.FS

// Server represents the web server
type Server struct {
        db             *sql.DB
        templates      map[string]*template.Template
        crontabFile    string
        jobsMu         sync.RWMutex
        jobs           map[string]*JobInfo // job id -&gt; job info
        parser         *cron.Parser
        eventChan      chan JobEvent
        updateInterval time.Duration
}

// JobInfo represents a cron job in the UI
type JobInfo struct {
        ID         string // SHA256 of command
        Command    string
        Schedule   string
        NextRun    time.Time
        LastRun    time.Time
        LastStatus string // "success", "failed", "running", ""
        IsRunning  bool
        Enabled    bool
        CreatedAt  time.Time
        UpdatedAt  time.Time
        SortIndex  int // original order in crontab
}

// JobEvent represents job execution events
type JobEvent struct {
        JobID      string
        Command    string
        Schedule   string
        EventType  string // "started", "completed", "failed"
        ExitCode   int
        StartedAt  time.Time
        FinishedAt time.Time
}

// TemplateData holds data for templates
type TemplateData struct {
        Jobs        []*JobInfo
        CurrentYear int
        ViewMode    string // "cards" or "list"
        Theme       string // "light", "dark", "auto"
        SortMode    string // "default", "lastrun", "nextrun"
}

// Config holds server configuration
type Config struct {
        Address        string
        CrontabFile    string
        DBPath         string
        UpdateInterval time.Duration
}

// New creates a new web server
func New(cfg Config) (*Server, error) <span class="cov8" title="1">{
        // open database
        db, err := sql.Open("sqlite", cfg.DBPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // enable WAL mode for better concurrency
        <span class="cov8" title="1">if _, walErr := db.Exec("PRAGMA journal_mode=WAL"); walErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to set WAL mode: %w", walErr)
        }</span>

        // create tables
        <span class="cov8" title="1">if createErr := createTables(db); createErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create tables: %w", createErr)
        }</span>

        // parse templates
        <span class="cov8" title="1">templates, err := parseTemplates()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse templates: %w", err)
        }</span>

        <span class="cov8" title="1">parser := cron.NewParser(cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor)

        return &amp;Server{
                db:             db,
                templates:      templates,
                crontabFile:    cfg.CrontabFile,
                jobs:           make(map[string]*JobInfo),
                parser:         &amp;parser,
                eventChan:      make(chan JobEvent, 1000),
                updateInterval: cfg.UpdateInterval,
        }, nil</span>
}

// Run starts the web server
func (s *Server) Run(ctx context.Context, address string) error <span class="cov8" title="1">{
        // start background job sync
        go s.syncJobs(ctx)

        // start event processor
        go s.processEvents(ctx)

        // setup routes
        mux := http.NewServeMux()

        // pages
        mux.HandleFunc("GET /", s.handleDashboard)

        // api endpoints for HTMX
        mux.HandleFunc("GET /api/jobs", s.handleJobsPartial)
        mux.HandleFunc("POST /api/view-mode", s.handleViewModeToggle)
        mux.HandleFunc("POST /api/theme", s.handleThemeToggle)
        mux.HandleFunc("POST /api/sort-mode", s.handleSortModeChange)
        mux.HandleFunc("POST /api/sort-toggle", s.handleSortToggle)

        // static files
        mux.Handle("GET /static/", http.FileServer(http.FS(staticFS)))

        server := &amp;http.Server{
                Addr:              address,
                Handler:           mux,
                ReadHeaderTimeout: 5 * time.Second,
                WriteTimeout:      30 * time.Second,
                IdleTimeout:       30 * time.Second,
        }

        go func() </span><span class="cov8" title="1">{
                &lt;-ctx.Done()
                shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                defer cancel()
                if err := server.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to shutdown server: %v", err)
                }</span>
        }()

        <span class="cov8" title="1">log.Printf("[INFO] starting web server on %s", address)
        return server.ListenAndServe()</span>
}

// OnJobStart implements service.JobEventHandler interface
func (s *Server) OnJobStart(command, schedule string, startTime time.Time) <span class="cov8" title="1">{
        event := JobEvent{
                JobID:     HashCommand(command),
                Command:   command,
                Schedule:  schedule,
                EventType: "started",
                StartedAt: startTime,
        }
        select </span>{
        case s.eventChan &lt;- event:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0">
                log.Printf("[WARN] event channel full, dropping event")</span>
        }
}

// OnJobComplete implements service.JobEventHandler interface
func (s *Server) OnJobComplete(command, schedule string, startTime, endTime time.Time, exitCode int, err error) <span class="cov8" title="1">{
        eventType := "completed"
        if err != nil </span><span class="cov8" title="1">{
                eventType = "failed"
        }</span>
        <span class="cov8" title="1">event := JobEvent{
                JobID:      HashCommand(command),
                Command:    command,
                Schedule:   schedule,
                EventType:  eventType,
                ExitCode:   exitCode,
                StartedAt:  startTime,
                FinishedAt: endTime,
        }
        select </span>{
        case s.eventChan &lt;- event:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0">
                log.Printf("[WARN] event channel full, dropping event")</span>
        }
}

// syncJobs syncs jobs from crontab file
func (s *Server) syncJobs(ctx context.Context) <span class="cov8" title="1">{
        // initial sync
        s.loadJobsFromCrontab()

        // if update interval is 0, don't start ticker
        if s.updateInterval &lt;= 0 </span><span class="cov0" title="0">{
                &lt;-ctx.Done()
                return
        }</span>

        <span class="cov8" title="1">ticker := time.NewTicker(s.updateInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        s.loadJobsFromCrontab()</span>
                }
        }
}

// loadJobsFromCrontab loads jobs from crontab file
func (s *Server) loadJobsFromCrontab() <span class="cov8" title="1">{
        parser := crontab.New(s.crontabFile, 0, nil)
        specs, err := parser.List()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to parse crontab: %v", err)
                return
        }</span>

        <span class="cov8" title="1">s.jobsMu.Lock()
        defer s.jobsMu.Unlock()

        // mark all jobs as potentially removed
        oldJobs := make(map[string]bool)
        for id := range s.jobs </span><span class="cov8" title="1">{
                oldJobs[id] = true
        }</span>

        <span class="cov8" title="1">for idx, spec := range specs </span><span class="cov8" title="1">{
                id := HashCommand(spec.Command)

                // parse schedule for next run calculation
                schedule, err := s.parser.Parse(spec.Spec)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] failed to parse schedule %q: %v", spec.Spec, err)
                        continue</span>
                }

                // update or create job
                <span class="cov8" title="1">if job, exists := s.jobs[id]; exists </span><span class="cov8" title="1">{
                        job.Schedule = spec.Spec
                        job.NextRun = schedule.Next(time.Now())
                        job.UpdatedAt = time.Now()
                        job.SortIndex = idx // update sort index in case order changed
                        delete(oldJobs, id)
                }</span> else<span class="cov8" title="1"> {
                        s.jobs[id] = &amp;JobInfo{
                                ID:        id,
                                Command:   spec.Command,
                                Schedule:  spec.Spec,
                                NextRun:   schedule.Next(time.Now()),
                                Enabled:   true,
                                CreatedAt: time.Now(),
                                UpdatedAt: time.Now(),
                                SortIndex: idx,
                        }
                }</span>
        }

        // remove jobs that no longer exist
        <span class="cov8" title="1">for id := range oldJobs </span><span class="cov0" title="0">{
                delete(s.jobs, id)
        }</span>

        // persist to database
        <span class="cov8" title="1">s.persistJobs()</span>
}

// persistJobs saves jobs to database
func (s *Server) persistJobs() <span class="cov8" title="1">{
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to begin transaction: %v", err)
                return
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        for _, job := range s.jobs </span><span class="cov8" title="1">{
                // determine status to save
                status := job.LastStatus
                if job.IsRunning </span><span class="cov8" title="1">{
                        status = "running"
                }</span>

                <span class="cov8" title="1">_, err := tx.Exec(`
                        INSERT OR REPLACE INTO jobs 
                        (id, command, schedule, next_run, last_run, last_status, enabled, created_at, updated_at, sort_index)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                        job.ID, job.Command, job.Schedule, job.NextRun.Unix(),
                        job.LastRun.Unix(), status, job.Enabled,
                        job.CreatedAt.Unix(), job.UpdatedAt.Unix(), job.SortIndex)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to persist job: %v", err)
                }</span>
        }

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to commit transaction: %v", err)
        }</span>
}

// processEvents processes job execution events
func (s *Server) processEvents(ctx context.Context) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case event := &lt;-s.eventChan:<span class="cov8" title="1">
                        s.handleJobEvent(event)</span>
                }
        }
}

// handleJobEvent handles a single job event
func (s *Server) handleJobEvent(event JobEvent) <span class="cov8" title="1">{
        id := HashCommand(event.Command)

        s.jobsMu.Lock()
        defer s.jobsMu.Unlock()

        job, exists := s.jobs[id]
        if !exists </span><span class="cov8" title="1">{
                // create new job entry if it doesn't exist
                job = &amp;JobInfo{
                        ID:        id,
                        Command:   event.Command,
                        Schedule:  event.Schedule,
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                        Enabled:   true,
                }
                // calculate next run for new job
                if schedule, err := s.parser.Parse(event.Schedule); err == nil </span><span class="cov8" title="1">{
                        job.NextRun = schedule.Next(time.Now())
                        log.Printf("[DEBUG] calculated NextRun for new job %s: %v", event.Command, job.NextRun)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("[ERROR] failed to parse schedule %q for job %s: %v", event.Schedule, event.Command, err)
                }</span>
                <span class="cov8" title="1">s.jobs[id] = job</span>
        }

        <span class="cov8" title="1">switch event.EventType </span>{
        case "started":<span class="cov8" title="1">
                job.IsRunning = true
                job.LastRun = event.StartedAt
                job.LastStatus = "running"
                job.UpdatedAt = time.Now()</span>
        case "completed":<span class="cov8" title="1">
                job.IsRunning = false
                job.LastStatus = "success"
                job.UpdatedAt = time.Now()
                // recalculate next run after job completion
                if schedule, err := s.parser.Parse(job.Schedule); err == nil </span><span class="cov8" title="1">{
                        job.NextRun = schedule.Next(time.Now())
                }</span>
        case "failed":<span class="cov8" title="1">
                job.IsRunning = false
                job.LastStatus = "failed"
                job.UpdatedAt = time.Now()
                // recalculate next run after job failure
                if schedule, err := s.parser.Parse(job.Schedule); err == nil </span><span class="cov8" title="1">{
                        job.NextRun = schedule.Next(time.Now())
                }</span>
        }
        <span class="cov8" title="1">job.UpdatedAt = time.Now()

        // save execution to database
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := s.db.ExecContext(ctx, `
                INSERT INTO executions (job_id, started_at, finished_at, status, exit_code)
                VALUES (?, ?, ?, ?, ?)`,
                id, event.StartedAt.Unix(), event.FinishedAt.Unix(),
                job.LastStatus, event.ExitCode)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to save execution: %v", err)
        }</span>
}

// handleDashboard renders the main dashboard
func (s *Server) handleDashboard(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        viewMode := getViewMode(r)
        theme := getTheme(r)
        sortMode := s.getSortMode(r)

        s.jobsMu.RLock()
        jobs := make([]*JobInfo, 0, len(s.jobs))
        for _, job := range s.jobs </span><span class="cov8" title="1">{
                // recalculate next run times before sorting
                if schedule, err := s.parser.Parse(job.Schedule); err == nil </span><span class="cov8" title="1">{
                        job.NextRun = schedule.Next(time.Now())
                }</span>
                <span class="cov8" title="1">jobs = append(jobs, job)</span>
        }
        <span class="cov8" title="1">s.jobsMu.RUnlock()

        // sort jobs based on selected mode
        s.sortJobs(jobs, sortMode)

        data := TemplateData{
                Jobs:        jobs,
                CurrentYear: time.Now().Year(),
                ViewMode:    viewMode,
                Theme:       theme,
                SortMode:    sortMode,
        }

        s.render(w, http.StatusOK, "base.html", "base", data)</span>
}

// handleJobsPartial returns the jobs list partial for HTMX polling
func (s *Server) handleJobsPartial(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        viewMode := getViewMode(r)
        sortMode := s.getSortMode(r)

        s.jobsMu.RLock()
        jobs := make([]*JobInfo, 0, len(s.jobs))
        for _, job := range s.jobs </span><span class="cov8" title="1">{
                // recalculate next run times
                if schedule, err := s.parser.Parse(job.Schedule); err == nil </span><span class="cov8" title="1">{
                        job.NextRun = schedule.Next(time.Now())
                }</span>
                <span class="cov8" title="1">jobs = append(jobs, job)</span>
        }
        <span class="cov8" title="1">s.jobsMu.RUnlock()

        // sort jobs based on selected mode
        s.sortJobs(jobs, sortMode)

        data := TemplateData{
                Jobs:     jobs,
                ViewMode: viewMode,
                SortMode: sortMode,
        }

        tmplName := "jobs-cards"
        if viewMode == "list" </span><span class="cov8" title="1">{
                tmplName = "jobs-list"
        }</span>

        <span class="cov8" title="1">s.render(w, http.StatusOK, "partials/jobs.html", tmplName, data)</span>
}

// handleViewModeToggle toggles between card and list view
func (s *Server) handleViewModeToggle(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        currentMode := getViewMode(r)
        newMode := "list"
        if currentMode == "list" </span><span class="cov8" title="1">{
                newMode = "cards"
        }</span>

        <span class="cov8" title="1">http.SetCookie(w, &amp;http.Cookie{
                Name:     "view-mode",
                Value:    newMode,
                Path:     "/",
                MaxAge:   365 * 24 * 60 * 60, // 1 year
                HttpOnly: true,
                SameSite: http.SameSiteLaxMode,
        })

        // trigger full page refresh to update the toggle button icon
        w.Header().Set("HX-Refresh", "true")
        w.WriteHeader(http.StatusOK)</span>
}

// handleThemeToggle toggles the theme
func (s *Server) handleThemeToggle(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        currentTheme := getTheme(r)

        // cycle: light -&gt; dark -&gt; auto -&gt; light
        nextTheme := "light"
        switch currentTheme </span>{
        case "light":<span class="cov8" title="1">
                nextTheme = "dark"</span>
        case "dark":<span class="cov8" title="1">
                nextTheme = "auto"</span>
        case "auto":<span class="cov8" title="1">
                nextTheme = "light"</span>
        }

        <span class="cov8" title="1">http.SetCookie(w, &amp;http.Cookie{
                Name:     "theme",
                Value:    nextTheme,
                Path:     "/",
                MaxAge:   365 * 24 * 60 * 60, // 1 year
                HttpOnly: false,              // allow JS to read for immediate update
                SameSite: http.SameSiteLaxMode,
        })

        // trigger full page refresh for theme change
        w.Header().Set("HX-Refresh", "true")
        w.WriteHeader(http.StatusOK)</span>
}

// handleSortToggle toggles between sort modes
func (s *Server) handleSortToggle(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        currentMode := s.getSortMode(r)

        // cycle: default -&gt; lastrun -&gt; nextrun -&gt; default
        nextMode := "default"
        switch currentMode </span>{
        case "default":<span class="cov0" title="0">
                nextMode = "lastrun"</span>
        case "lastrun":<span class="cov0" title="0">
                nextMode = "nextrun"</span>
        case "nextrun":<span class="cov0" title="0">
                nextMode = "default"</span>
        }

        <span class="cov0" title="0">http.SetCookie(w, &amp;http.Cookie{
                Name:     "sort-mode",
                Value:    nextMode,
                Path:     "/",
                MaxAge:   365 * 24 * 60 * 60, // 1 year
                HttpOnly: true,
                SameSite: http.SameSiteLaxMode,
        })

        // get sorted jobs for the new mode
        viewMode := getViewMode(r)
        s.jobsMu.RLock()
        jobs := make([]*JobInfo, 0, len(s.jobs))
        for _, job := range s.jobs </span><span class="cov0" title="0">{
                // recalculate next run times before sorting
                if schedule, err := s.parser.Parse(job.Schedule); err == nil </span><span class="cov0" title="0">{
                        job.NextRun = schedule.Next(time.Now())
                }</span>
                <span class="cov0" title="0">jobs = append(jobs, job)</span>
        }
        <span class="cov0" title="0">s.jobsMu.RUnlock()

        // sort jobs based on new mode
        s.sortJobs(jobs, nextMode)

        // prepare template data
        data := TemplateData{
                Jobs:     jobs,
                ViewMode: viewMode,
                SortMode: nextMode,
        }

        // determine template name
        tmplName := "jobs-cards"
        if viewMode == "list" </span><span class="cov0" title="0">{
                tmplName = "jobs-list"
        }</span>

        // get the template and render jobs HTML
        <span class="cov0" title="0">tmpl, ok := s.templates["partials/jobs.html"]
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Template not found", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">var jobsHTML bytes.Buffer
        if err := tmpl.ExecuteTemplate(&amp;jobsHTML, tmplName, data); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Template error", http.StatusInternalServerError)
                return
        }</span>

        // get sort button label
        <span class="cov0" title="0">sortLabel := "Original Order"
        switch nextMode </span>{
        case "lastrun":<span class="cov0" title="0">
                sortLabel = "Last Run"</span>
        case "nextrun":<span class="cov0" title="0">
                sortLabel = "Next Run"</span>
        }

        // return jobs with OOB update for sort button
        <span class="cov0" title="0">fmt.Fprintf(w, `%s
&lt;span class="sort-label" hx-swap-oob="innerHTML" id="sort-label"&gt;%s&lt;/span&gt;`,
                jobsHTML.String(), sortLabel)</span>
}

// handleSortModeChange changes the sort mode
func (s *Server) handleSortModeChange(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        sortMode := r.FormValue("sort")

        // validate sort mode
        switch sortMode </span>{
        case "default", "lastrun", "nextrun":<span class="cov8" title="1"></span>
                // valid
        default:<span class="cov8" title="1">
                sortMode = "default"</span>
        }

        <span class="cov8" title="1">http.SetCookie(w, &amp;http.Cookie{
                Name:     "sort-mode",
                Value:    sortMode,
                Path:     "/",
                MaxAge:   365 * 24 * 60 * 60, // 1 year
                HttpOnly: true,
                SameSite: http.SameSiteLaxMode,
        })

        // return the jobs partial with sorted jobs
        viewMode := getViewMode(r)

        s.jobsMu.RLock()
        jobs := make([]*JobInfo, 0, len(s.jobs))
        for _, job := range s.jobs </span><span class="cov0" title="0">{
                // recalculate next run times
                if schedule, err := s.parser.Parse(job.Schedule); err == nil </span><span class="cov0" title="0">{
                        job.NextRun = schedule.Next(time.Now())
                }</span>
                <span class="cov0" title="0">jobs = append(jobs, job)</span>
        }
        <span class="cov8" title="1">s.jobsMu.RUnlock()

        // sort jobs based on selected mode
        s.sortJobs(jobs, sortMode)

        data := TemplateData{
                Jobs:     jobs,
                ViewMode: viewMode,
                SortMode: sortMode,
        }

        tmplName := "jobs-cards"
        if viewMode == "list" </span><span class="cov0" title="0">{
                tmplName = "jobs-list"
        }</span>

        // set header to tell HTMX to swap the jobs container
        <span class="cov8" title="1">w.Header().Set("HX-Retarget", "#jobs-container")
        w.Header().Set("HX-Reswap", "innerHTML")

        s.render(w, http.StatusOK, "partials/jobs.html", tmplName, data)</span>
}

// render renders a template
func (s *Server) render(w http.ResponseWriter, status int, page, tmplName string, data any) <span class="cov8" title="1">{
        tmpl, ok := s.templates[page]
        if !ok </span><span class="cov0" title="0">{
                log.Printf("[ERROR] template %s not found", page)
                http.Error(w, "Template not found", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">buf := new(bytes.Buffer)
        if err := tmpl.ExecuteTemplate(buf, tmplName, data); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to execute template: %v", err)
                http.Error(w, "Template error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "text/html; charset=utf-8")
        w.WriteHeader(status)
        if _, err := buf.WriteTo(w); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] failed to write response: %v", err)
        }</span>
}

// parseTemplates parses all templates
func parseTemplates() (map[string]*template.Template, error) <span class="cov8" title="1">{
        templates := make(map[string]*template.Template)

        funcMap := template.FuncMap{
                "humanTime":     humanTime,
                "humanDuration": humanDuration,
                "truncate":      truncate,
                "timeUntil":     timeUntil,
        }

        // parse base template with all partials
        base, err := template.New("base.html").Funcs(funcMap).ParseFS(templatesFS,
                "templates/base.html",
                "templates/dashboard.html",
                "templates/partials/*.html")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse base template: %w", err)
        }</span>
        <span class="cov8" title="1">templates["base.html"] = base

        // parse partials separately for HTMX requests
        partials, err := template.New("jobs.html").Funcs(funcMap).ParseFS(templatesFS,
                "templates/partials/*.html")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse partials: %w", err)
        }</span>
        <span class="cov8" title="1">templates["partials/jobs.html"] = partials

        return templates, nil</span>
}

// createTables creates database tables
func createTables(db *sql.DB) error <span class="cov8" title="1">{
        queries := []string{
                `CREATE TABLE IF NOT EXISTS jobs (
                        id TEXT PRIMARY KEY,
                        command TEXT NOT NULL,
                        schedule TEXT NOT NULL,
                        next_run INTEGER,
                        last_run INTEGER,
                        last_status TEXT,
                        enabled BOOLEAN DEFAULT 1,
                        created_at INTEGER,
                        updated_at INTEGER,
                        sort_index INTEGER DEFAULT 0
                )`,
                `CREATE TABLE IF NOT EXISTS executions (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        job_id TEXT,
                        started_at INTEGER,
                        finished_at INTEGER,
                        status TEXT,
                        exit_code INTEGER,
                        FOREIGN KEY (job_id) REFERENCES jobs(id)
                )`,
                `CREATE INDEX IF NOT EXISTS idx_executions_job_id ON executions(job_id)`,
                `CREATE INDEX IF NOT EXISTS idx_executions_started_at ON executions(started_at)`,
        }

        for _, query := range queries </span><span class="cov8" title="1">{
                if _, err := db.Exec(query); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute query: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// helper functions

// HashCommand generates a SHA256 hash of a command for use as a unique ID
func HashCommand(cmd string) string <span class="cov8" title="1">{
        h := sha256.Sum256([]byte(cmd))
        return hex.EncodeToString(h[:])
}</span>

func getViewMode(r *http.Request) string <span class="cov8" title="1">{
        cookie, err := r.Cookie("view-mode")
        if err != nil </span><span class="cov8" title="1">{
                return "cards" // default
        }</span>
        <span class="cov8" title="1">if cookie.Value == "list" </span><span class="cov8" title="1">{
                return "list"
        }</span>
        <span class="cov8" title="1">return "cards"</span>
}

func getTheme(r *http.Request) string <span class="cov8" title="1">{
        cookie, err := r.Cookie("theme")
        if err != nil </span><span class="cov8" title="1">{
                return "auto" // default
        }</span>
        <span class="cov8" title="1">switch cookie.Value </span>{
        case "light", "dark", "auto":<span class="cov8" title="1">
                return cookie.Value</span>
        default:<span class="cov0" title="0">
                return "auto"</span>
        }
}

// template helper functions

func humanTime(t time.Time) string <span class="cov8" title="1">{
        if t.IsZero() </span><span class="cov0" title="0">{
                return "Never"
        }</span>
        <span class="cov8" title="1">return t.Format("Jan 2, 15:04:05")</span>
}

func humanDuration(d time.Duration) string <span class="cov8" title="1">{
        if d &lt; time.Minute </span><span class="cov8" title="1">{
                return fmt.Sprintf("%ds", int(d.Seconds()))
        }</span>
        <span class="cov8" title="1">if d &lt; time.Hour </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dm", int(d.Minutes()))
        }</span>
        <span class="cov8" title="1">if d &lt; 24*time.Hour </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dh", int(d.Hours()))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%dd", int(d.Hours()/24))</span>
}

func timeUntil(t time.Time) string <span class="cov8" title="1">{
        if t.IsZero() </span><span class="cov0" title="0">{
                return "Never"
        }</span>
        <span class="cov8" title="1">d := time.Until(t)
        if d &lt; 0 </span><span class="cov0" title="0">{
                return "Overdue"
        }</span>
        <span class="cov8" title="1">return humanDuration(d)</span>
}

func truncate(s string, n int) string <span class="cov8" title="1">{
        if len(s) &lt;= n </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:n] + "..."</span>
}

// getSortMode gets the sort mode from cookie or defaults to "default"
func (s *Server) getSortMode(r *http.Request) string <span class="cov8" title="1">{
        cookie, err := r.Cookie("sort-mode")
        if err != nil || cookie.Value == "" </span><span class="cov8" title="1">{
                return "default"
        }</span>
        // validate sort mode
        <span class="cov8" title="1">switch cookie.Value </span>{
        case "default", "lastrun", "nextrun":<span class="cov8" title="1">
                return cookie.Value</span>
        default:<span class="cov8" title="1">
                return "default"</span>
        }
}

// sortJobs sorts jobs based on the sort mode
func (s *Server) sortJobs(jobs []*JobInfo, sortMode string) <span class="cov8" title="1">{
        switch sortMode </span>{
        case "lastrun":<span class="cov8" title="1">
                // sort by last run time, most recent first
                sort.Slice(jobs, func(i, j int) bool </span><span class="cov8" title="1">{
                        // handle zero times - put them at the end
                        if jobs[i].LastRun.IsZero() &amp;&amp; jobs[j].LastRun.IsZero() </span><span class="cov0" title="0">{
                                return jobs[i].SortIndex &lt; jobs[j].SortIndex // maintain default order for unrun jobs
                        }</span>
                        <span class="cov8" title="1">if jobs[i].LastRun.IsZero() </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">if jobs[j].LastRun.IsZero() </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov8" title="1">return jobs[i].LastRun.After(jobs[j].LastRun)</span>
                })
        case "nextrun":<span class="cov8" title="1">
                // sort by next run time, soonest first
                sort.Slice(jobs, func(i, j int) bool </span><span class="cov8" title="1">{
                        // handle zero times - put them at the end
                        if jobs[i].NextRun.IsZero() &amp;&amp; jobs[j].NextRun.IsZero() </span><span class="cov0" title="0">{
                                return jobs[i].SortIndex &lt; jobs[j].SortIndex
                        }</span>
                        <span class="cov8" title="1">if jobs[i].NextRun.IsZero() </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">if jobs[j].NextRun.IsZero() </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov8" title="1">return jobs[i].NextRun.Before(jobs[j].NextRun)</span>
                })
        default:<span class="cov8" title="1"> // "default"
                // sort by original crontab order
                sort.Slice(jobs, func(i, j int) bool </span><span class="cov8" title="1">{
                        return jobs[i].SortIndex &lt; jobs[j].SortIndex
                }</span>)
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
